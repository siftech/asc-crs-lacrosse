;;; -------------------------------------------------------------------------
;;; COPYRIGHT START
;;; COPYRIGHT END
;;; -------------------------------------------------------------------------

;;; A class for tasks that invoke the langchain-based llm tool.

(cl:in-package :fuzzbomb)

(defclass lacrosse-gen-pov-blob-task (lacrosse-task)
  (
    (blob-path :initarg :patch-path :initform nil :accessor patch-path
               :documentation "Path of blob file generated by LLM")
  )
)

(defmethod initialize-instance :after ((task lacrosse-gen-pov-blob-task) &key)
  (dbug :top "initialize-instance :after ((task lacrosse-gen-pov-blob-task): ~s" task)
  (if *lacrosse-stub-pov-blob-p*
      ;; - choose a vuln report (for now, the only isabel-report) for input
      ;; - make up a filename for output
    (let ((repo-name ""))
      ;;(when (slot-exists-p (target task) 'cp-address)
      ;;  (setf repo-name (repo-name-from-repo-address (cp-address (target task)))))
      (let* (
             ;;(source-pathname (first (target-sources (target task))))
             (cmds (list (list "/lacrosse/code/tools/gen-pov-blob-stub.sh"
                               (namestring (output-dir (target task)))
                               repo-name)))
             ;;(cmd-str (format nil "~{~A~^ && ~}" (mapcar #'uiop:escape-sh-command cmds)))
             ;; the above escape is a lovely pattern, but foils the attempt to use a glob
             ;; in the activate step.
             (cmd-str (format nil "~{~A~^ && ~}"
                              (mapcar #'(lambda (cmd-list)
                                          (format nil "~{~A~^ ~}" cmd-list))
                                      cmds)))
             )
        (dbug :top "  cmd-str: ~s" cmd-str)
        (setf (cmd task) (uiop:escape-sh-command `("bash" "-c" ,cmd-str)))))
      (let* (
             (json-pathname (build-json-input-file task))
             (cmds `(("cd" "/lacrosse/code/langchain")
                     ("source" "/build/venvs/virtualenvs/lacrosse-llm-*/bin/activate")
                     ("python" "-m" "lacrosse_llm.patch"
                               "--json-input-file"
                               ,(namestring json-pathname)
                               "--json-output-file "
                               ,(namestring
                                 (merge-pathnames (make-pathname :name "patch-outputs"
                                                                 :type "json")
                                                  (uiop:ensure-directory-pathname
                                                   (output-dir (target task)))))
                               ;; temporarily hard-coded
                               "--opus"
                               )
                      ("echo" "GEN-PATCH-LLM - TASK RESULT: DONE")))
             ;;(cmd-str (format nil "~{~A~^ && ~}" (mapcar #'uiop:escape-sh-command cmds)))
             ;; the above escape is a lovely pattern, but foils the attempt to use a glob
             ;; in the activate step.
             (cmd-str (format nil "~{~A~^ && ~}"
                              (mapcar #'(lambda (cmd-list)
                                          (format nil "~{~A~^ ~}" cmd-list))
                                      cmds)))
             )
        (dbug :top "  cmd-str: ~s" cmd-str)
        (setf (cmd task) (uiop:escape-sh-command `("bash" "-c" ,cmd-str))))))

(defmethod pre-exec ((task lacrosse-gen-pov-blob-task))
  (dbug :amp "Executing lacrosse-gen-pov-blob-task."))

(defmethod post-exec ((task lacrosse-gen-pov-blob-task))
  (dbug :top "post-exec for lacrosse-gen-pov-blob-task"))

(defmethod task-applies-to-target-p ((task-class-name (eql 'lacrosse-gen-pov-blob-task)) target-node)
  (declare (ignore target-node))
  nil)

  ;; (dbug :docker-task "task-applies-to-target-p lacrosse-gen-pov-blob-task")
  ;; (let ((target (target target-node)))
  ;;   (dbug :target "(dir target): ~s" (dir target))
  ;;   (dbug :target "(executable-target-p target): ~s" (executable-target-p target))
  ;;   (dbug :target "(buildable-target-p target): ~s" (buildable-target-p target))
  ;;   (dbug :target "(target-sources target): ~s" (target-sources target))
  ;;   (dbug :target "(blobs target): ~s" (target-sources target))
    
  ;;   (cond
  ;;    ((lacrosse-cp-target-p target)
  ;;     ;; if it's challenge problem, then there should be a stub or maybe real task for this!
  ;;     ;; Check the task preconds and go!
  ;;     (and (make-pov-blob target)
  ;; 	   (let* (;;(repo-name (repo-name-from-repo-address (cp-address target)))
  ;; 		  (source-dir (source-path target))
  ;; 		  ;;(cp-dir (concatenate 'string (dir target) repo-name))
  ;; 		  (cp-dir (dir target))
  ;; 		  )
	     
  ;; 	     (dbug :top "lacrosse-gen-pov-blob-task - cp dir: ~a (~a), source dir: ~a (~a)"
  ;; 		   cp-dir (uiop:directory-exists-p cp-dir)
  ;; 		   source-dir (uiop:directory-exists-p source-dir))
  ;; 	     (dbug :top "lacrosse-gen-pov-blob-task - is executable in dir: ~a"
  ;; 		   (is-executable-in-dir source-dir))
  ;; 	     (and
  ;; 	      cp-dir
  ;; 	      source-dir
  ;; 	      (uiop:directory-exists-p cp-dir)
  ;; 	      (uiop:directory-exists-p source-dir)))))
  ;;    (t
  ;;     ;; otherwise, this is a legacy target that will go away by July.
  ;;     ;; It's prob dvrf-pwnable and there's no stub support for it.
  ;;     nil))))

(defmethod process-line ((task lacrosse-gen-pov-blob-task) line)
  (dbug :top "got line [~A]" line)
  (cond
    ((cl-ppcre:scan-to-strings "GEN-POV-BLOB-STUB - TASK RESULT: DONE" line)
      (let* ((output-dir (namestring (output-dir (target task))))
             (blob-file (concatenate 'string output-dir "sample_solve.bin"))
             (blobs nil))
        (when (slot-exists-p (target task) 'blobs)
          (setf blobs (append (blobs (target task)) (list blob-file))))
        (dbug :top "Sending blob to optimus....")
        (send-message-to-optimi :type :challenge-project-update
                                :target-id (id (target task))
                                :blobs blobs
                                :dir (dir (target task))
                                :make-pov-blob nil
                                :run-pov T)))
    ;  (T
    ;   (send-message-to-optimi :type :challenge-project-update
    ;                             :target-id (id (target task))
    ;                             :blobs nil
    ;                             :dir (dir (target task))
    ;                             :run-pov nil))
     ))

; (defgeneric build-json-input-file (task)
;   (:method  ((task lacrosse-gen-pov-blob-task))
;     (let* ((output-directory (uiop:ensure-directory-pathname (output-dir (target task))))
;            (json-pathname (merge-pathnames
;                            (make-pathname :name "patch-input" :type "json")
;                            output-directory))
;            (target-pathname (parse-namestring (first (target-sources (target task)))))
;            (patch-pathname (merge-pathnames
;                             (make-pathname :name (pathname-name target-pathname)
;                                            :type "patch")
;                             output-directory))
;            (patched-pathname (merge-pathnames
;                               (make-pathname :name (format nil "~a-patched"
;                                                            (pathname-name target-pathname))
;                                              :type (pathname-type target-pathname))
;                               output-directory))
;            (output-obj (list
;                           (cons "file" (namestring target-pathname))
;                           (cons "patch_file" (namestring patch-pathname))
;                           (cons "patched_file" (namestring patched-pathname))
;                           (cons "patch_function" "null")
;                           (cons "line_number" 0))))
;       (declare (type pathname
;                      json-pathname target-pathname patch-pathname
;                      output-directory
;                      patched-pathname))
;       ; (dbug :top "JSON output obj: ~a" output-obj)
;       (setf (patch-path task) patch-pathname)
;       (when (not (uiop:file-exists-p json-pathname))
;         (uiop:with-output-file (str json-pathname)
;           (cl-json:encode-json-alist output-obj str)))
;       (dbug :top "    JSON input file: ~a~%" json-pathname)
;       json-pathname)))
