;;; random.lisp
;;; -------------------------------------------------------------------------
;;; COPYRIGHT START
;;; COPYRIGHT END
;;; -------------------------------------------------------------------------

;;;-------------------------------------------------------------------------
;;; Methods to store and load random seeds from a file and then access
;;; them sequentially as though they were dynamically generated by
;;; (make-random-seed).  This has the effect of giving us reproducible
;;; multi-stream random number generation without going to the trouble of
;;; storing the associations between seeds and tasks streams they are
;;; used to generate; the association is made dynamically as the tasks
;;; are declared, so that as long as our random number seed file has enough
;;; seeds in it to begin with, and as long as the tasks are generated in
;;; the same order, the association will be reproducible.
;;;-------------------------------------------------------------------------

(in-package :musliner)

;;;-------------------------------------------------------------------------

(defparameter *max-randoms* 100)
(defvar *random-filename* "random-seeds")
(defvar *random-directory* (namestring (asdf:system-source-directory :musliner-tools)))

(defvar *random-extension*
  #+allegro ".allegro"
  #+ccl ".ccl"
  #+cmu ".cmucl"
  #+lispworks ".lispworks"
  #+sbcl ".sbcl"
  #-(or allegro ccl cmu lispworks sbcl)
  (error "Add extension for your lisp dialect: see random.lisp"))

;;; Changed the pathname generation function to be more general than it was
;;; when originally used with dsched
;;; 7/2/96 -- Paul Rybski
;;; The use of make-pathname was not correct.  Fixed it, added some
;;; error-checking and changed to with-open-file, which does all the
;;; UNWIND-PROTECTing to close files automagically. [2001/06/01:goldman]
;;; This whole function, particularly how it opens files, should probably
;;; be overhauled.  The difficulties I had getting it to work on CMULISP
;;;
(defun generate-randoms (&key (directory *random-directory*)
                              (filename *random-filename*)
                           (extension *random-extension*))
  "Generate a set of random states (effectively, seeds) for reproducible randomicity."
  (let ((fullname
         (concatenate 'string
                      directory
                      filename
                      extension)))
    (with-open-file (file fullname :direction :output
                          :if-exists :supersede)
      (format t "Generating ~A randoms, at about 1 second each ...~%"
              *max-randoms*)
      (dotimes (i *max-randoms*)
        ;; as far as I can determine, format %S does not reliably print
        ;; readably in CMUCL.  Nor am I sure it should.  
        #+(or cmu sbcl)
        (let ((*print-readably* t))
          (print (new-random-state) file)
          (terpri file))
        #-(or cmu sbcl)
        (format file "~S~%" (new-random-state))))
    (format t "Done...~%")
    (values)))


;;;-------------------------------------------------------------------------
(defvar *random-states* nil)

;;; Changed the pathname generation function to be more general than it was
;;; when originally used with dsched
;;; 7/2/96 -- Paul Rybski
;;; fixed and tidied.  See comments to fixes to generate-randoms
;;; 
(defun read-randoms (&key (directory *random-directory*)
                          (filename *random-filename*)
                          ;; note the following probably isn't the
                          ;; best thing to do for portability, but
                          ;; I'm stumped for a better alternative
                          ;;  
                          (extension *random-extension*))
  (let ((fullname
         (concatenate 'string
                      directory
                      filename
                      extension)))
    (unless (file-exists-p fullname)
      (error "No random seed file ~A" fullname))
    (dbug :top "Reading random seeds from file ~A" fullname)
    (with-open-file (file fullname :direction :input)
      (setf *random-states* nil)
      (dotimes (i *max-randoms*)
        (push (read file) *random-states*))
      (values))))

;;;-------------------------------------------------------------------------
(defun reset-randoms ()
  (read-randoms)
  (reset-random-choice-stream))

;;;-------------------------------------------------------------------------
(defun get-random-state ()
  (when (not *random-states*)
        (dbug :top "Ran out of cached random states!")
        (reset-randoms))
  (pop *random-states*))

;;;-------------------------------------------------------------------------
;;;-------------------------------------------------------------------------
;;; Because Allegro (and possibly others) use the real-time clock to
;;; form new random states in #'make-random-state, we cannot call it twice
;;; in a row too close together, or it will return the same random state.
;;; This function adds necessary delay.   Empirical testing shows that the
;;; fourth digit from the right (= seconds) is the least significant one that
;;; affects the random state generation.
;;; This version compares new rand state w/ last generated state to ensure they
;;; are diff, rather than just waiting.  It still takes about a second
;;; apiece in Allegro, but this is a little better....

(when (not (fboundp 'while))
  (defmacro while (pred &body body)
    `(loop (unless ,pred (return nil)) ,@body)))

(defvar *last-new-random-state* nil)

(defun new-random-state () "Generates a unique random state (DJM)"
  (let (s)
         (while (equalp (setf s (make-random-state t))
                        *last-new-random-state*))
         (setf *last-new-random-state* s)))


;;;(defun test-nrs ()
;;;  (let ((i 0))
;;;  (while t
;;;     (new-random-state)
;;;     (format t "~A~%" (incf i)))))

;;;-------------------------------------------------------------------------
;;; this is just a quick test function to make sure that none
;;; of the random seeds leads to pathologically all-equal values when
;;; provided to random.  We had this problem occur when reading in seeds
;;; from an older lisp that got expanded into larger seeds for current lisp.
;;; This helps identify the problem...

(defun test-randoms (&aux s v)
  (dotimes (i *max-randoms*)
        (setf s (get-random-state))
        (setf v (random 100 s))
        ;(format t "~A " i)
        (when (and (eq v (random 100 s)) (eq v (random 100 s))
                        (eq v (random 100 s)))
                (error "Random returned same val 4 times in a row w/ seed number ~A: ~A" i s)))
  (format t "If got here, test was OK~%"))

