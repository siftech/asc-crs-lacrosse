use sha2::{Digest as _, Sha256};

/// A PRNG seeded from an arbitrary blob.
///
/// This is an implementation of the ChaCha20 keystream based on RFC8439, initialized with a SHA256
/// hash of the input.
#[derive(Debug)]
pub struct Prng {
    key: [u32; 8],
    counter: u32,
    nonce: [u32; 3],

    block: [u8; 64],
    i: usize,
}

impl Prng {
    /// Initializes the PRNG with the given data as a seed.
    pub fn new(data: &[u8]) -> Prng {
        let mut hasher = Sha256::new();
        hasher.update(data);
        let hash = hasher.finalize();
        let bytes: [u8; 32] = *hash.as_ref();
        let mut seed = [0; 8];
        for i in 0..8 {
            // UNWRAP: The length is statically 4.
            let chunk = bytes[4 * i..4 * (i + 1)].try_into().unwrap();
            seed[i] = u32::from_le_bytes(chunk);
        }
        Prng::with_seed(seed, [0; 3])
    }

    /// Initializes the PRNG with the given key and nonce.
    pub fn with_seed(key: [u32; 8], nonce: [u32; 3]) -> Prng {
        let mut out = Prng {
            counter: 0,
            key,
            nonce,
            block: [0; 64],
            i: 0,
        };
        out.next_block();
        out
    }

    fn next_block(&mut self) {
        self.counter += 1;

        let mut state = [
            0x61707865,
            0x3320646e,
            0x79622d32,
            0x6b206574,
            self.key[0],
            self.key[1],
            self.key[2],
            self.key[3],
            self.key[4],
            self.key[5],
            self.key[6],
            self.key[7],
            self.counter,
            self.nonce[0],
            self.nonce[1],
            self.nonce[2],
        ];
        chacha20(&mut state);

        let mut block = [0; 64];
        for i in 0..16 {
            block[4 * i..4 * (i + 1)].copy_from_slice(&u32::to_le_bytes(state[i]));
        }
        self.block = block;
        self.i = 0;
    }

    fn generate_byte(&mut self) -> u8 {
        let out = self.block[self.i];
        self.i += 1;
        if self.i == 64 {
            self.next_block();
        }
        out
    }

    /// Fills the buffer with generated bytes.
    pub fn generate_bytes(&mut self, out: &mut [u8]) {
        for b in out.iter_mut() {
            *b = self.generate_byte();
        }
    }
}

/// The test vector from 2.4.2 of RFC8439.
#[test]
fn test_vector() {
    let mut prng = Prng::with_seed(
        [
            0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c, 0x13121110, 0x17161514, 0x1b1a1918,
            0x1f1e1d1c,
        ],
        [0x00000000, 0x4a000000, 0x00000000],
    );

    let mut bytes = [0; 128];
    prng.generate_bytes(&mut bytes);
    assert_eq!(
        bytes,
        [
            0x22, 0x4f, 0x51, 0xf3, 0x40, 0x1b, 0xd9, 0xe1, 0x2f, 0xde, 0x27, 0x6f, 0xb8, 0x63,
            0x1d, 0xed, 0x8c, 0x13, 0x1f, 0x82, 0x3d, 0x2c, 0x06, 0xe2, 0x7e, 0x4f, 0xca, 0xec,
            0x9e, 0xf3, 0xcf, 0x78, 0x8a, 0x3b, 0x0a, 0xa3, 0x72, 0x60, 0x0a, 0x92, 0xb5, 0x79,
            0x74, 0xcd, 0xed, 0x2b, 0x93, 0x34, 0x79, 0x4c, 0xba, 0x40, 0xc6, 0x3e, 0x34, 0xcd,
            0xea, 0x21, 0x2c, 0x4c, 0xf0, 0x7d, 0x41, 0xb7, 0x69, 0xa6, 0x74, 0x9f, 0x3f, 0x63,
            0x0f, 0x41, 0x22, 0xca, 0xfe, 0x28, 0xec, 0x4d, 0xc4, 0x7e, 0x26, 0xd4, 0x34, 0x6d,
            0x70, 0xb9, 0x8c, 0x73, 0xf3, 0xe9, 0xc5, 0x3a, 0xc4, 0x0c, 0x59, 0x45, 0x39, 0x8b,
            0x6e, 0xda, 0x1a, 0x83, 0x2c, 0x89, 0xc1, 0x67, 0xea, 0xcd, 0x90, 0x1d, 0x7e, 0x2b,
            0xf3, 0x63, 0x74, 0x03, 0x73, 0x20, 0x1a, 0xa1, 0x88, 0xfb, 0xbc, 0xe8, 0x39, 0x91,
            0xc4, 0xed,
        ]
    );
}

fn chacha20(state: &mut [u32; 16]) {
    let initial_state = *state;
    for _ in 0..10 {
        quarter_round(state, 0, 4, 8, 12);
        quarter_round(state, 1, 5, 9, 13);
        quarter_round(state, 2, 6, 10, 14);
        quarter_round(state, 3, 7, 11, 15);

        quarter_round(state, 0, 5, 10, 15);
        quarter_round(state, 1, 6, 11, 12);
        quarter_round(state, 2, 7, 8, 13);
        quarter_round(state, 3, 4, 9, 14);
    }
    for i in 0..16 {
        state[i] = state[i].wrapping_add(initial_state[i]);
    }
}

/// The test vector from 2.3.2 of RFC8439.
#[test]
fn test_block_function() {
    let mut state = [
        0x61707865, 0x3320646e, 0x79622d32, 0x6b206574, 0x03020100, 0x07060504, 0x0b0a0908,
        0x0f0e0d0c, 0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c, 0x00000001, 0x09000000,
        0x4a000000, 0x00000000,
    ];
    chacha20(&mut state);
    assert_eq!(
        state,
        [
            0xe4e7f110, 0x15593bd1, 0x1fdd0f50, 0xc47120a3, 0xc7f4d1c7, 0x0368c033, 0x9aaa2204,
            0x4e6cd4c3, 0x466482d2, 0x09aa9f07, 0x05d7c214, 0xa2028bd9, 0xd19c12b5, 0xb94e16de,
            0xe883d0cb, 0x4e3c50a2,
        ]
    );
}

fn quarter_round(state: &mut [u32; 16], x: usize, y: usize, z: usize, w: usize) {
    let mut a = state[x];
    let mut b = state[y];
    let mut c = state[z];
    let mut d = state[w];

    a = a.wrapping_add(b);
    d = (d ^ a).rotate_left(16);
    c = c.wrapping_add(d);
    b = (b ^ c).rotate_left(12);
    a = a.wrapping_add(b);
    d = (d ^ a).rotate_left(8);
    c = c.wrapping_add(d);
    b = (b ^ c).rotate_left(7);

    state[x] = a;
    state[y] = b;
    state[z] = c;
    state[w] = d;
}

/// The test vector from 2.2.1 of RFC8439.
#[test]
fn test_quarter_round() {
    let mut state = [
        0x879531e0, 0xc5ecf37d, 0x516461b1, 0xc9a62f8a, 0x44c20ef3, 0x3390af7f, 0xd9fc690b,
        0x2a5f714c, 0x53372767, 0xb00a5631, 0x974c541a, 0x359e9963, 0x5c971061, 0x3d631689,
        0x2098d9d6, 0x91dbd320,
    ];
    quarter_round(&mut state, 2, 7, 8, 13);
    assert_eq!(
        state,
        [
            0x879531e0, 0xc5ecf37d, 0xbdb886dc, 0xc9a62f8a, 0x44c20ef3, 0x3390af7f, 0xd9fc690b,
            0xcfacafd2, 0xe46bea80, 0xb00a5631, 0x974c541a, 0x359e9963, 0x5c971061, 0xccc07c79,
            0x2098d9d6, 0x91dbd320,
        ]
    );
}
