#!/bin/bash

# Turn on job control since non-interactivity might fool it into disabling it.
set -m

# this runs the gdb exploitable tool on a single crash found below the experdir (if any) 

# bash-ism to get location of script.
thisdir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && cd -P "$( dirname "$SOURCE" )" && /bin/pwd )"

# usage: run-exploitable experdir targetbin povname run-cmd
# Note targetbin should be an absolute path

echo "Starting run-exploitable"
echo "arg1 = $1"
echo "arg2 = $2"
echo "arg3 = $3"
echo "arg4 = $4"
echo "arg5 = $5"

# cd $1
# povname=`$thisdir/find-crashes |head -1`
# echo "find-crashes povname = [$povname]"

# if [ ! -f "$povname" ]
#  then
# 	echo "No crash pov found; trying an initial test case"
# 	povname=`$thisdir/find-test-cases |head -1`
# 	echo "find-test-cases povname = $povname"
# fi

# if [ ! -f "$povname" ]
#  then
# 	echo "No pov or test-case found; quitting"
# 	exit 1;
# fi

export povname=$3
export runcmd=$4
echo "povname = $povname"
echo "runcmd = $runcmd"

function get_exec_arch () {
  # determine the arch of the binary, returns results like ARM, X86-64
  local arch

  arch=`readelf -h "$1" 2>&1 | egrep -e '^[ \t]*Machine:' | sed -e 's/.* \(.*\$\)/\\1/'`
  # return the value
  if [ "x$arch" = "x" ]; then
    echo unknown
  else
    echo "$arch"
  fi
}

machine_arch=`uname -m`
target_arch=$(get_exec_arch "$2")

echo "Detected machine architecture as: ${machine_arch}"
echo "Analyzing architecture for target binary: $2"
echo "Detected target binary architecture as: ${target_arch}."

# TODO: For now, if the target binary architecture matches the machine
# architecture, we run the old original method. We need to add a flag here to
# allow a preference of emulation in this situation.

# TODO: This should be a command line flag for the script that defaults to yes.
prefer_native=yes

if [ "z${machine_arch}" = "zx86_64" \
    -a "z${target_arch}" = "zX86-64" \
    -a "z${prefer_native}" = "zyes" ]; then

    echo "Preferring native exploitablity analysis of target binary..."

gdb <<END
source $thisdir/../exploitable/exploitable/exploitable.py
file $2
$runcmd
# dont wrap "where" output
set width 200
where
exploitable
#fuzzy_pov_stack_search $povname
kill
quit
END

else
    echo "Preferring QEMU emulation exploitability analysis of target binary..."

    echo "WARNING: The QEMU/gdb-exploitable code path is not stable!"

    # It isn't stable because QEMU has only a partial implementation of
    # the gdbserver protocol and gdb-exploitable manages to stumble over
    # it. But, we'll let it go on so we see how it fails.

    # Pick the right QEMU and architecture.
    echo "Detecting appropriate QEMU user space binary...."
    qemu_root="/neo-fuzz/code/afl-other-arch/qemu_mode/qemu-2.3.0"
    case "$target_arch" in
        "X86-64")
            gdb_arch="i386:x86-64"
            qemu_bin="${qemu_root}/x86_64-linux-user/qemu-x86_64"
            ;;
        "ARM")
            gdb_arch="arm"
            qemu_bin="${qemu_root}/arm-linux-user/qemu-arm"
            ;;
        *)
            echo "Error: Script $0 could not determine architecture of file: $2"
            echo "Isabel can not execute!"
            exit 1
            ;;
    esac
    
    if [ -f "$qemu_bin" ]; then
        echo "Detected qemu_bin at: $qemu_bin"
    else 
        echo "QEMU executable not found: $qemu_bin"
        echo "Isabel can not execute!"
        exit 1
    fi
    
    port=`expr $CIRCA_BASEPORT + 5`
    echo "Computed gdb server port (derived from CIRCA_BASEPORT + 5): $port"
    
    # Execute the QEMU server for the PoV
    cmd="$qemu_bin -g $port $2 < $povname 2>&1 &"
    echo "Executing QEMU as gdb server for target binary: $cmd"

    # NOTE: The below can't seem to be just $cmd. It won't execute right.
    # So I have to keep the echo and the command in sync.
    $qemu_bin -g $port "$2" < "$povname" 2>&1 &
    qemu_pid=$!
    
    echo "QEMUs background pid is: $qemu_pid"
    echo "Wait 2 seconds (TODO: use netstat to check for listening port)...."
    sleep 2
    
    echo "Starting up gdb-multiarch and and executing run-exploitable...."

    # TODO: potentially add a sysroot for arm in the qemu location of needed.
    gdb-multiarch -q --nh <<END
set architecture $gdb_arch
source $thisdir/../exploitable/exploitable/exploitable.py
set sysroot target:
file $2
target remote localhost:$port
continue
# dont wrap "where" output
set width 200
where
exploitable
#fuzzy_pov_stack_search $povname
kill
quit
END

fi

echo "Ending run-exploitable"
